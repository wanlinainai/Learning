# Java

## 虚拟线程

虚拟线程是Java19引入的一种轻量级线程，在其他语言中被称为协程、纤程、绿色线程、用户态线程等。

线程特点：

- 线程是由操作系统创建并调度的资源
- 线程切换会耗费大量CPU时间
- 一个系统能同时调度的线程数量是有限的，通常在几百到几千之间

线程是一个重量级资源。在服务器端，对用户请求，通常都实现为一个线程处理一个请求。由于用户的请求数往往超过系统所支持的调度的线程数量，所以通常使用线程池来解决这个问题。

对于需要大量处理IO的请求来说，使用线程是很低效的，因为一旦读写 IO，线程必须进入等待状态，直到IO数据返回。常见的IO操作包含：

- 读写文件
- 读写网络，例如HTTP请求
- 读写数据库，JDBC实现的网络调用

一个处理HTTP请求的线程，在读写网络、文件的时候就会进入等待状态：

真正由CPU执行的代码消耗时间非常少，线程大多数是在等待IO。这类任务就是IO密集型任务。

为了可以高效的执行IO密集型，Java19引入了虚拟线程，虚拟线程接口和普通线程是一样的，但是执行方式不同。

> 虚拟线程不是由操作系统调度，而是有普通线程调度，成千上百的虚拟线程由一个线程调度。任何时刻只能执行一个虚拟线程。一旦这个虚拟线程执行一个IO进行等待的时候，他会被立即挂起，之后执行下一个虚拟线程。什么时候虚拟线程返回了，挂起的虚拟线程才会被再次调度。因此，许多的虚拟线程可以在一个普通线程中交替执行。

单独看一个虚拟线程的代码：

```java
void register() {
    config = readConfigFile("./config.json"); // #1
    if (config.useFullName) {
        name = req.firstName + " " + req.lastName;
    }
    insertInto(db, name); // #2
    if (config.cache) {
        redis.set(key, name); // #3
    }
}
```

在1、2、3处，执行到这些地方的时候会自动挂起，并切换到其他虚拟线程执行。等到数据返回之后，当前虚拟线程再次调度并执行，看起来是同步的，但是其实是异步的。

### 使用虚拟线程

方法一：直接创建虚拟线程

```java
// 1 直接创建虚拟线程
        Thread vt = Thread.startVirtualThread(() -> {
            try {
                System.out.println("Start virtual thread1...");
                Thread.sleep(1000);
                System.out.println("End virtual thread1...");
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });
```

方法二：创建虚拟线程但是不启动，手动调用start方法启动

```java
        // 2 创建虚拟线程但不自动启动，手动调用start方法启动
        Thread vt2 = Thread.ofVirtual().unstarted(() -> {
            try {
                System.out.println("Start virtual thread2....");
                Thread.sleep(2000);
                System.out.println("End virtual thread2....");
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });
        vt2.start();
```

方法三：通过`ThreadFactory`创建虚拟线程，手动调用start方法启动

```java
        // 3 通过虚拟线程的ThreadFactory创建虚拟线程，手动调用start方法启动
        ThreadFactory factory = Thread.ofVirtual().factory();
        // 创建VirtualThread
        Thread vt3 = factory.newThread(() -> {
            try {
                System.out.println("Start virtual thread3....");
                Thread.sleep(3000);
                System.out.println("End virtual thread3....");
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
        vt3.start();
```

方法四：创建调度执行器执行虚拟线程

```java
        // 4 创建调度执行器执行虚拟线程
        ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();
        // 创建大量线程并调度
        ThreadFactory factory1 = Thread.ofVirtual().factory();
        for (int i = 0; i < 100000; i++) {
            Thread vt4 = factory1.newThread(() -> {
                System.out.println("我是李白");
            });
            executor.submit(vt4);
            // 也可以直接传入Runnable或者Callable
            executor.submit(() -> {
                try {
                    System.out.println("Start virtual thread...");
                    Thread.sleep(4000);
                    System.out.println("End virtual thread...");
                    return true;
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            });
        }
```

> 由于虚拟线程是非常轻量级的资源，因此，用时创建，用完就扔，不需要池化虚拟线程。

虚拟线程在Java21正式发布 ，Java19/20是预览功能，默认关闭，需要添加参数启动：

```shell
java --source 19 --enable-preview Main.java
```

### 练习

使用虚拟线程创建100000个任务观察：

```java
        // 虚拟线程
        ExecutorService es_vir = Executors.newVirtualThreadPerTaskExecutor();
        long start_vir = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            es_vir.submit(() -> {
                Thread.sleep(1000);
                return 0;
            });
        }
        es_vir.close();
        long end_vir = System.currentTimeMillis();
        System.out.println();
        System.out.printf("All virtual threads end at %s ms.\n", end_vir - start_vir);
```

为了比较，我们加上正常使用线程池的代码：（用的是CachedThreadPool）

```java
        int numTasks = 100_000;
        ExecutorService es = Executors.newCachedThreadPool();
        long start = System.currentTimeMillis();
        // 收集任务返回的 Future 以等待所有任务完成
        List<Future<Integer>> futures = new ArrayList<>(numTasks);
        for (int i = 0; i < numTasks; i++) {
            futures.add(es.submit(() -> {
                try {
                    Thread.sleep(1000); // 模拟阻塞操作
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                return 0;
            }));
        }
        // 等待所有任务执行完毕
        for (Future<Integer> future : futures) {
            try {
                future.get();
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        }
        es.shutdown();
        long end = System.currentTimeMillis();
        System.out.printf("All cached thread pool tasks end at %d ms.%n", end - start);
```

运行两者：

虚拟线程的运行结果如下：

![image-20250620111110706](随手记/image-20250620111110706.png)

使用CachedThreadPool运行结果如下：

![image-20250620111135450](随手记/image-20250620111135450.png)

差距还是十分明显的。





## dify部署大模型

本地使用ollama搭建了一个qwen3的模型。在设置dify的模型供应商的时候会出现127.0.0.1不能访问的情况。

如果本地安装了docket desktop，可以直接使用：

```shell
http://host.docker.internal:11434
```

监听本地ollama模型







## git pull 代码之后出现文件夹只读的问题

Windows解除只读属性的命令：

```shell
attrib -r /s /d *
```

## 百度关闭AI智能搜索

```shell
baidu.com##._content-border_zc167_4.cu-border.sc-aladdin.sc-cover-card
baidu.com##._swiper-container_1ktf7_2.wd-ai-index-pc.swiper-box_33d
baidu.com##.result-op
```

Adguard中用户过滤器加上如上几行即可。

![image-20251110114630210](随手记/image-20251110114630210.png)

## 阿里TransmittableThreadLocal

如果使用ThreadLocal：

```java
public class ThreadLocalTest {
    private static final ThreadLocal THREAD_LOCAL = new ThreadLocal();

    public static void main(String[] args) {
        THREAD_LOCAL.set(1);

        System.out.println(StrUtil.format("父线程的值是:{}", THREAD_LOCAL.get()));

        // 子线程
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(StrUtil.format("子线程的值是:{}", THREAD_LOCAL.get()));
            }
        }, "子线程").start();
    }
}
```

运行结果：![image-20260118200103651](images/随手记/image-20260118200103651.png)

子线程获取不到父线程的值。

将ThreadLocal换成TransmittableThreadLocal之后可以看到打印值：

![image-20260118200245015](images/随手记/image-20260118200245015.png)

如果在日常业务中使用，如下：

定义**ThreadUtils**工具类：

```java
public class ThreadUtils {
    private static final ThreadLocal<String> THREAD_LOCAL = new ThreadLocal<>();

    public static void set(String value) {
        THREAD_LOCAL.set(value);
    }

    public static String get() {
        return THREAD_LOCAL.get();
    }

    public static void remove(){
        THREAD_LOCAL.remove();
    }
}
```

Controller中先设置ThreadLocal：

```java
    @GetMapping("/threadLocalTest")
    public String threadLocalTest() {
        ThreadUtils.set("zhangsan");
        testService.threadLocalTest();
        return "";
    }
```

实现类中：

```java
    @Override
    public void threadLocalTest() {
        String userName = ThreadUtils.get();
        System.out.println("测试线程用户名称:" + userName);
        logService.recordLog();
    }

    @Override
    @Async
    public void recordLog() {
        System.out.println("记录日志信息：操作人是:" + ThreadUtils.get());
    }
```

结果：

![image-20260118201731805](images/随手记/image-20260118201731805.png)

工具类中的**ThreadLocal**换成**TransmittableThreadLocal**之后

结果：

![image-20260118201840543](images/随手记/image-20260118201840543.png)





# Python

## multiprocessing（跨平台版本的多进程模块）

- 父子进程

```python
import time
from multiprocessing import Process
import os

# 子进程要执行的代码
def run_proc(name):
    time.sleep(3)
    print(f'Run child process {name}, ({os.getpid()}).....')
if __name__ == '__main__':
    print(f'Parent process {os.getpid()}')
    p = Process(target=run_proc, args=('test',))
    print(f'子进程开始...')

    p.start()
    p.join()
    print('Child Process end....')
```

执行结果：![image-20251115164608415](随手记/image-20251115164608415.png)

使用Process启动进程，`target`设置执行方法，`args`设置成方法所需参数。`start`方法开始执行，`join`方法等待子线程执行完成之后父线程执行。

- Pool 进程池

```python
from multiprocessing import Pool
import os
import time
import random

def long_time_task(name):
    print(f'Run child process start....({os.getpid()})')
    startTime = time.time()
    time.sleep(3)
    endTime = time.time()
    print(f'Task {name} execute {endTime - startTime} seconds ....')
if __name__ == '__main__':
    print(f'Parent process {os.getpid()}')
    p = Pool(4)
    for i in range(5):
        p.apply_async(long_time_task, args=(i, ))
    print('Waiting for all subprocesses done...')
    p.close()
    p.join()
    print('ALl subprocesses done...')
```

执行结果：![image-20251115164925457](随手记/image-20251115164925457.png)

仔细观察执行过程的话会发现0,1,2,3进程会同时立即执行，4任务需要等到之前的某一个任务完成之后才会执行，原因是设置的Pool大小是4，也就是池子是4，0，1，2,3已经占据了全部，需要等到资源释放才能重新进入4任务。

`close`方法是关闭方法，关闭之后进程不能继续添加。

- 父子进程通信

```python
from multiprocessing import Process, Queue
import os, time, random

def write(q):
    print(f'写进程{os.getpid()}')
    for value in ['A', 'B', 'C']:
        print(f'Put {value} to queue...')
        q.put(value)
        time.sleep(random.random())

def read(q):
    print(f'读进程{os.getpid()}')
    while True:
        # block=True，会一直等到队列中有数据，timeout是设置等待的时长，如果超过的报错
        value = q.get(True, timeout=2)
        print(f'Get {value} from queue')

if __name__ == '__main__':
    q= Queue()
    pw = Process(target=write, args=(q, ))
    pr = Process(target=read, args=(q, ))
    pw.start()
    pr.start()
    pw.join()
    pr.terminate()
```

执行结果：![image-20251116174858010](images/随手记/image-20251116174858010.png)

创建队列，开启进程向队列中写数据和读数据，最后关闭。

## 多线程







## argparse模块

是一个用于命令行、参数和子命令解析器。

可以轻松编写用户友好的命令行接口。程序定义需要的参数，之后argparse将弄清如何从sys.argv解析出那一些参数。

1. 创建解析器

```python
```





## httpx模块

Httpx是Python3的全功能 HTTP 客户端，提供了同步和异步API，官网API: [https://www.python-httpx.org/](https://link.zhihu.com/?target=https%3A//www.python-httpx.org/)

- 安装

```shell
pip install httpx # 安装库
pip install httpx[http2] # 安装http2的支持
pip install httpx[brotli] # 安装brotli解码器的支持
```

- Get请求

```python
import httpx
from fake_useragent import UserAgent

headers = {
    'user-agent': UserAgent().random,
}
params = {
    'wd': 'python'
}
response = httpx.get('https://www.baidu.com/s', params=params, headers=headers)
response.encoding = response.charset_encoding
print(response.text)
```

会触发百度的反爬虫，其实拿不到结果。

- post请求(表单)

```python
data = {'key1': 'value1', 'key2': 'value2'}
r = httpx.post("https://httpbin.org/post", data=data)
print(r.text)
```

**客户端**

`httpx.Client()`可以代替`reuqests.Session()`。`Client()`使用http连接池。

- 创建Client

```python
with httpx.Client() as client:
    pass

client = httpx.Client()
try:
    pass
finally:
    client.close()
```

- 发送请求

```python
# 共用请求头
url = 'http://httpbin.org/headers'
headers = {'user-agent': 'my-app/0.0.1'}
with httpx.Client(headers=headers) as client:
    r = client.get(url)

print(r.json()['headers']['User-Agent'])

# 公共 + 私有
headers = {'X-Auth': "from-client"}
params = {'client_id': "client1"}
with httpx.Client(headers=headers, params=params) as client:
    headers_ = {'X-Custom': 'from-request'}
    params_ = {'request_id': 'request1'}
    r = client.get('https://example.com', headers=headers_, params=params_)
print(r.request.url) # https://example.com?client_id=client1&request_id=request1，可以看到参数中是结合了公共的 + 私有的值
print(r.request.headers['X-Auth']) # from-client
print(r.request.headers['X-Custom']) # from-request
```









# GIT

## git回退代码（删除提交，重新提交代码）

1. 本地回退（`git reset`）
2. 远程删除（`git push --force-with-lease`）：强制推送
3. 重新提交（`git commit `）

```shell
git reset --soft HEAD^

或者

git reset --soft <A的哈希值>
```

验证本地仓库的文件状态：

```shell
git status
```

删除远程仓库的错误提交

```shell
git push --force-with-lease origin ***
```

重新提交代码

```shell
git commit --author "****" -m "real commit"

git push origin ****
```

## MySQL

### 如何实现误删数据将数据还原

我们有一个数据表：``ruoyi-vue-pro`.`system_login_log``,我们删除了其中的一条记录。

![image-20260115222626800](images/随手记/image-20260115222626800.png)

4086的数据已经被删除了，但是我们发现是误操作。这时候需要看看使用binlog恢复了。前提需要开启Binlog（检查命令:`show variables  like 'log_bin'`，如果是`ON`是打开的）

1. 检查Binlog日志文件：

```shell
root@VM-0-5-ubuntu:/usr/bin# ls -lh /var/lib/mysql/binlog.*
```

结果如下：

![image-20260115222808164](images/随手记/image-20260115222808164.png)

找到最近删除的日志：是`binlog.000022`。

2. 打开看看日志内容

```shell
mysqlbinlog --no-defaults --base64-output=DECODE-ROWS -v /var/lib/mysql/binlog.000022
```

![image-20260115222937665](images/随手记/image-20260115222937665.png)

观察到其中有一个delete日志记录。我们可以根据这个日志内容将删除数据恢复。

3. 我们使用Java实现数据恢复，主要就是将日志文件拿到，之后使用文件读写恢复即可。文件我已经拷贝到了本地。

```java
public class RestoreData {
    // 数据库配置
    private static final String DB_URL = "jdbc:mysql://localhost:3306/ruoyi-vue-pro?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai";
    private static final String DB_USER = "admin";
    private static final String DB_PASS = "Zhang123456.";

    // 日志文件路径
    private static final String LOG_FILE_PATH = "/Users/a1234/github_repository/Test-new-code/src/test/java/com/zxh/test/mysql/test/binlog_decoded.log";

    public static void main(String[] args) {
        restoreData(LOG_FILE_PATH);
    }

    public static void restoreData(String filePath) {
        Connection conn = null;
        Statement stmt = null;
        BufferedReader reader = null;

        try {
            // 1. 建立数据库连接
            conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASS);
            conn.setAutoCommit(false); // 开启事务，方便批量提交
            stmt = conn.createStatement();

            reader = new BufferedReader(new FileReader(filePath));
            String line;

            // 正则匹配 @1=xxx 这种格式
            // Group 1: 索引号, Group 2: 值
            Pattern columnPattern = Pattern.compile("###\\s+@(\\d+)=(.*)");

            String currentTable = null;
            Map<Integer, String> currentRowValues = new TreeMap<>(); // 使用TreeMap保证字段按顺序排列
            int batchCount = 0;
            int totalRestored = 0;

            System.out.println("开始解析并恢复数据...");

            while ((line = reader.readLine()) != null) {
                line = line.trim();

                // 2. 识别新的一行数据的开始 (DELETE FROM ...)
                if (line.startsWith("### DELETE FROM")) {
                    // 如果上一行数据存在，先保存上一行
                    if (!currentRowValues.isEmpty() && currentTable != null) {
                        String sql = buildInsertSql(currentTable, currentRowValues);
                        stmt.addBatch(sql);
                        batchCount++;
                        totalRestored++;
                    }

                    // 重置状态，准备读取新的一行
                    currentRowValues.clear();
                    // 提取表名: ### DELETE FROM `db`.`table` -> `db`.`table`
                    currentTable = line.substring(line.indexOf("FROM") + 5).trim();
                }
                // 3. 识别字段值 (### @1=...)
                else if (line.startsWith("###") && line.contains("@")) {
                    Matcher matcher = columnPattern.matcher(line);
                    if (matcher.find()) {
                        int colIndex = Integer.parseInt(matcher.group(1));
                        String colValue = matcher.group(2).trim();
                        currentRowValues.put(colIndex, colValue);
                    }
                }

                // 4. 批量执行 (每1000条提交一次)
                if (batchCount >= 1000) {
                    stmt.executeBatch();
                    conn.commit();
                    System.out.println("已恢复 " + totalRestored + " 条记录...");
                    batchCount = 0;
                }
            }

            // 5. 处理最后一条记录
            if (!currentRowValues.isEmpty() && currentTable != null) {
                String sql = buildInsertSql(currentTable, currentRowValues);
                stmt.addBatch(sql);
                stmt.executeBatch();
                conn.commit();
                totalRestored++;
            }

            System.out.println("恢复完成！共恢复数据: " + totalRestored + " 条。");

        } catch (Exception e) {
            e.printStackTrace();
            try { if (conn != null) conn.rollback(); } catch (Exception ex) {}
        } finally {
            try {
                if (reader != null) reader.close();
                if (stmt != null) stmt.close();
                if (conn != null) conn.close();
            } catch (Exception e) {}
        }
    }

    /**
     * 构建 INSERT SQL 语句
     */
    private static String buildInsertSql(String tableName, Map<Integer, String> values) {
        StringBuilder sb = new StringBuilder();
        sb.append("INSERT INTO ").append(tableName).append(" VALUES (");

        boolean first = true;
        for (String val : values.values()) {
            if (!first) {
                sb.append(", ");
            }
            // 这里的 val 是从日志里直接拿出来的，例如 'test001' (带引号) 或 100 (不带引号)
            // MySQL Binlog decode 后的格式通常可以直接用于 SQL，除了 bit 类型可能需要微调
            // 但通常 b'0' 这种格式 MySQL 是支持直接 Insert 的
            sb.append(val);
            first = false;
        }
        sb.append(");");
        return sb.toString();
    }
}
```









































